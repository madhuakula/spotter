package vap

import (
	"bytes"
	"fmt"
	"io"

	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	"sigs.k8s.io/yaml"
)

// OutputFormat represents the output format for VAP resources
type OutputFormat string

const (
	// OutputFormatYAML outputs resources in YAML format
	OutputFormatYAML OutputFormat = "yaml"
	// OutputFormatJSON outputs resources in JSON format
	OutputFormatJSON OutputFormat = "json"
)

// FormatOptions contains options for formatting VAP resources
type FormatOptions struct {
	// Format specifies the output format (yaml or json)
	Format OutputFormat
	// IncludeComments adds helpful comments to the YAML output
	IncludeComments bool
	// SeparateFiles indicates whether to output each resource separately
	SeparateFiles bool
	// IndentSize specifies the number of spaces for indentation
	IndentSize int
}

// DefaultFormatOptions returns default formatting options
func DefaultFormatOptions() *FormatOptions {
	return &FormatOptions{
		Format:          OutputFormatYAML,
		IncludeComments: true,
		SeparateFiles:   false,
		IndentSize:      2,
	}
}

// FormatVAPResources formats ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding resources
func FormatVAPResources(policies []admissionregistrationv1.ValidatingAdmissionPolicy, bindings []admissionregistrationv1.ValidatingAdmissionPolicyBinding, options *FormatOptions) ([]byte, error) {
	if options == nil {
		options = DefaultFormatOptions()
	}

	var buf bytes.Buffer

	// Add header comment if YAML format with comments
	if options.Format == OutputFormatYAML && options.IncludeComments {
		buf.WriteString("# ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding resources\n")
		buf.WriteString("# Generated by Spotter - https://github.com/madhuakula/spotter\n")
		buf.WriteString("# Apply these resources to your Kubernetes cluster to enforce Spotter rules natively\n\n")
	}

	// Format policies
	for i, policy := range policies {
		if options.Format == OutputFormatYAML && options.IncludeComments {
			buf.WriteString(fmt.Sprintf("# ValidatingAdmissionPolicy: %s\n", policy.Name))
			if policy.Annotations != nil {
				if title := policy.Annotations["spotter.dev/rule-title"]; title != "" {
					buf.WriteString(fmt.Sprintf("# Rule: %s\n", title))
				}
				if description := policy.Annotations["spotter.dev/rule-description"]; description != "" {
					buf.WriteString(fmt.Sprintf("# Description: %s\n", description))
				}
				if severity := policy.Annotations["spotter.dev/rule-severity"]; severity != "" {
					buf.WriteString(fmt.Sprintf("# Severity: %s\n", severity))
				}
			}
		}

		data, err := formatResource(&policy, options)
		if err != nil {
			return nil, fmt.Errorf("failed to format policy %s: %w", policy.Name, err)
		}
		buf.Write(data)

		// Add separator between resources
		if i < len(policies)-1 || len(bindings) > 0 {
			buf.WriteString("\n---\n\n")
		}
	}

	// Format bindings
	for i, binding := range bindings {
		if options.Format == OutputFormatYAML && options.IncludeComments {
			buf.WriteString(fmt.Sprintf("# ValidatingAdmissionPolicyBinding: %s\n", binding.Name))
			buf.WriteString(fmt.Sprintf("# Binds policy: %s\n", binding.Spec.PolicyName))
			if len(binding.Spec.ValidationActions) > 0 {
				buf.WriteString(fmt.Sprintf("# Validation actions: %v\n", binding.Spec.ValidationActions))
			}
		}

		data, err := formatResource(&binding, options)
		if err != nil {
			return nil, fmt.Errorf("failed to format binding %s: %w", binding.Name, err)
		}
		buf.Write(data)

		// Add separator between resources (except for the last one)
		if i < len(bindings)-1 {
			buf.WriteString("\n---\n\n")
		}
	}

	return buf.Bytes(), nil
}

// FormatPackExportResult formats the result of a pack export operation
func FormatPackExportResult(result *PackExportResult, options *FormatOptions) ([]byte, error) {
	if result == nil {
		return nil, fmt.Errorf("result cannot be nil")
	}

	return FormatVAPResources(result.Policies, result.Bindings, options)
}

// WriteVAPResources writes VAP resources to the specified writer
func WriteVAPResources(writer io.Writer, policies []admissionregistrationv1.ValidatingAdmissionPolicy, bindings []admissionregistrationv1.ValidatingAdmissionPolicyBinding, options *FormatOptions) error {
	data, err := FormatVAPResources(policies, bindings, options)
	if err != nil {
		return err
	}

	_, err = writer.Write(data)
	return err
}

// WritePackExportResult writes pack export result to the specified writer
func WritePackExportResult(writer io.Writer, result *PackExportResult, options *FormatOptions) error {
	data, err := FormatPackExportResult(result, options)
	if err != nil {
		return err
	}

	_, err = writer.Write(data)
	return err
}

// formatResource formats a single Kubernetes resource
func formatResource(resource interface{}, options *FormatOptions) ([]byte, error) {
	switch options.Format {
	case OutputFormatYAML:
		return yaml.Marshal(resource)
	case OutputFormatJSON:
		return yaml.Marshal(resource) // yaml.Marshal can output JSON too
	default:
		return nil, fmt.Errorf("unsupported format: %s", options.Format)
	}
}

// GenerateApplyInstructions generates instructions for applying the VAP resources
func GenerateApplyInstructions(policies []admissionregistrationv1.ValidatingAdmissionPolicy, bindings []admissionregistrationv1.ValidatingAdmissionPolicyBinding) string {
	var buf bytes.Buffer

	buf.WriteString("# Instructions for applying ValidatingAdmissionPolicy resources\n\n")
	buf.WriteString("## Prerequisites\n")
	buf.WriteString("- Kubernetes cluster version 1.30+ (ValidatingAdmissionPolicy is GA)\n")
	buf.WriteString("- Cluster administrator privileges\n")
	buf.WriteString("- ValidatingAdmissionPolicy feature enabled (enabled by default in 1.30+)\n\n")

	buf.WriteString("## Apply the resources\n")
	buf.WriteString("```bash\n")
	buf.WriteString("# Apply all policies and bindings\n")
	buf.WriteString("kubectl apply -f <this-file>\n\n")

	buf.WriteString("# Or apply them separately:\n")
	for _, policy := range policies {
		buf.WriteString(fmt.Sprintf("# kubectl apply -f - <<EOF\n# <policy-%s-yaml>\n# EOF\n", policy.Name))
	}
	for _, binding := range bindings {
		buf.WriteString(fmt.Sprintf("# kubectl apply -f - <<EOF\n# <binding-%s-yaml>\n# EOF\n", binding.Name))
	}
	buf.WriteString("```\n\n")

	buf.WriteString("## Verify the policies are active\n")
	buf.WriteString("```bash\n")
	buf.WriteString("# List all ValidatingAdmissionPolicies\n")
	buf.WriteString("kubectl get validatingadmissionpolicy\n\n")
	buf.WriteString("# List all ValidatingAdmissionPolicyBindings\n")
	buf.WriteString("kubectl get validatingadmissionpolicybinding\n\n")
	buf.WriteString("# Check policy status\n")
	for _, policy := range policies {
		buf.WriteString(fmt.Sprintf("kubectl describe validatingadmissionpolicy %s\n", policy.Name))
	}
	buf.WriteString("```\n\n")

	buf.WriteString("## Test the policies\n")
	buf.WriteString("Try creating resources that should trigger the validation rules to ensure they're working correctly.\n\n")

	buf.WriteString("## Remove the policies\n")
	buf.WriteString("```bash\n")
	buf.WriteString("# Remove all policies and bindings\n")
	buf.WriteString("kubectl delete -f <this-file>\n")
	buf.WriteString("```\n")

	return buf.String()
}